{% block extra_js %}
<script>
let cpuChartInstance = null;
let memoryChartInstance = null;
let diskChartInstance = null;
let txRxChartInstance = null;

document.addEventListener('DOMContentLoaded', () => {
    const hostname = "{{ hostname }}";

    function actualizarDetalle() {
        fetch(`/get_device_data/${hostname}`)
            .then(response => response.json())
            .then(data => {
                renderCharts(data);
                mostrarRiesgo(data);
            })
            .catch(err => console.error('Error al obtener datos del dispositivo:', err));
    }

    actualizarDetalle();
    setInterval(actualizarDetalle, 5000);

    document.querySelectorAll('.clickable-chart').forEach(chartContainer => {
        chartContainer.addEventListener('click', () => {
            const href = chartContainer.getAttribute('data-href');
            if (href) {
                window.location.href = href;
            }
        });
    });

    document.getElementById('downloadButton').addEventListener('click', () => {
        generarPDFReporte(hostname);
    });
});

function renderCharts(data) {
    const labels = data.timestamps; // Ya son milisegundos desde el backend

    if (cpuChartInstance) cpuChartInstance.destroy();
    if (memoryChartInstance) memoryChartInstance.destroy();
    if (diskChartInstance) diskChartInstance.destroy();
    if (txRxChartInstance) txRxChartInstance.destroy();

    // CPU
    const promedioCpu = data.cpu.length > 0 ? (data.cpu.reduce((sum, val) => sum + val, 0) / data.cpu.length).toFixed(1) : 'N/A';

    cpuChartInstance = new Chart(document.getElementById('cpuChart'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                label: `CPU (%) - Promedio: ${promedioCpu}%`,
                data: data.cpu,
                borderColor: '#00bcd4',
                backgroundColor: '#00bcd4',
                fill: false,
                tension: 0.3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, suggestedMax: 100, ticks: { stepSize: 10, color: 'white' }, grid: { color: '#4a5568' } },
                x: { 
                    type: 'time', 
                    time: {
                        unit: 'second', 
                        displayFormats: {
                            second: 'HH:mm:ss', 
                            minute: 'HH:mm'
                        },
                        tooltipFormat: 'HH:mm:ss'
                    },
                    grid: { color: '#4a5568' }, 
                    ticks: { 
                        color: 'white',
                        maxRotation: 45, 
                        minRotation: 45 
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                },
                datalabels: {
                    // Solo si necesitas datalabels en la línea, ajusta la visibilidad o quítalo si estorba
                    display: false // Deshabilitar por defecto para líneas para evitar aglomeración
                }
            }
        },
        plugins: [ChartDataLabels]
    });

    // Memoria
    const memoriaUso = data.memory.length > 0 ? data.memory[data.memory.length - 1] : 0;
    memoryChartInstance = new Chart(document.getElementById('memoryChart'), {
        type: 'doughnut',
        data: {
            labels: ['Usado (%)', 'Libre (%)'],
            datasets: [{ data: [memoriaUso, 100 - memoriaUso], backgroundColor: ['#ffee58', '#4a5568'] }]
        },
        options: {
            cutout: '70%',
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                },
                datalabels: {
                    formatter: (value, ctx) => `${value.toFixed(1)}%`,
                    color: function(ctx) {
                        return ctx.dataIndex === 0 ? 'black' : 'white';
                    },
                    font: { weight: 'normal', size: 12 }
                }
            }
        },
        plugins: [ChartDataLabels]
    });

// ===== Disco - Particiones (Usado y Libre con GB sobre las barras y porcentajes en la leyenda ordenados) =====

// 1. Obtener datos de particiones
const particiones = data.disks || {};
const particionesLabels = Object.keys(particiones);
const particionesUsado = Object.values(particiones);
const particionesLibre = particionesUsado.map(uso => 100 - uso);

const particionesTotalGb = data.disks_total_gb || {};
const particionesUsadoGb = data.disks_used_gb || {};

// 2. Solo los nombres al pie, en el mismo orden
const etiquetas = particionesLabels;

// 3. Construir leyenda dinámica en el mismo orden que las barras
let leyendaUsado = 'Usado (';
let leyendaLibre = 'Libre (';

etiquetas.forEach(label => {
    const porcentajeUsado = particiones[label] || 0;
    const porcentajeLibre = 100 - porcentajeUsado;
    leyendaUsado += `${label}: ${porcentajeUsado.toFixed(1)}% | `;
    leyendaLibre += `${label}: ${porcentajeLibre.toFixed(1)}% | `;
});

// Eliminar el último separador " | " y cerrar paréntesis
leyendaUsado = leyendaUsado.slice(0, -3) + ')';
leyendaLibre = leyendaLibre.slice(0, -3) + ')';

// 4. Render del gráfico
diskChartInstance = new Chart(document.getElementById('diskChart'), {
    type: 'bar',
    data: {
        labels: etiquetas,
        datasets: [
            {
                label: leyendaUsado,
                data: particionesUsado,
                backgroundColor: '#7b1fa2',
                datalabels: {
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    anchor: 'center',
                    align: 'center',
                    offset: 0,
                    formatter: (value, ctx) => {
                        const label = particionesLabels[ctx.dataIndex];
                        const usadoGb = particionesUsadoGb[label] || 0;
                        return `${usadoGb.toFixed(1)} GB`;
                    }
                }
            },
            {
                label: leyendaLibre,
                data: particionesLibre,
                backgroundColor: '#4a5568',
                datalabels: {
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    anchor: 'center',
                    align: 'center',
                    offset: 0,
                    formatter: (value, ctx) => {
                        const label = particionesLabels[ctx.dataIndex];
                        const totalGb = particionesTotalGb[label] || 0;
                        const usadoGb = particionesUsadoGb[label] || 0;
                        const libreGb = (totalGb - usadoGb).toFixed(1);
                        return `${libreGb} GB`;
                    }
                }
            }
        ]
    },
    options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, suggestedMax: 100, ticks: { stepSize: 10, color: 'white' }, grid: { color: '#4a5568' }, stacked: true },
                x: { grid: { color: '#4a5568' }, stacked: true, ticks: { color: 'white' } }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });


    // Tx/Rx
    txRxChartInstance = new Chart(document.getElementById('txRxChart'), {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'Bytes Tx (MB)',
                    data: data.tx,
                    backgroundColor: '#69f0ae',
                    datalabels: {
                        anchor: 'end',
                        align: 'end',
                        offset: 4,
                        color: '#000',
                        font: { size: 10 },
                        rotation: -90,
                        formatter: value => value.toFixed(2) + ' MB'
                    }
                },
                {
                    label: 'Bytes Rx (MB)',
                    data: data.rx,
                    backgroundColor: '#ff5252',
                    datalabels: {
                        anchor: 'end',
                        align: 'start',
                        offset: -4,
                        color: '#000',
                        font: { size: 10 },
                        rotation: -90,
                        formatter: value => value.toFixed(2) + ' MB'
                    }
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, ticks: { stepSize: calcularStepSize(data.tx, data.rx), color: 'white' }, grid: { color: '#4a5568' } },
                x: { 
                    type: 'time', 
                    time: {
                        unit: 'second', 
                        displayFormats: {
                            second: 'HH:mm:ss', 
                            minute: 'HH:mm'
                        },
                        tooltipFormat: 'HH:mm:ss'
                    },
                    grid: { color: '#4a5568' }, 
                    ticks: { 
                        color: 'white',
                        maxRotation: 45, 
                        minRotation: 45 
                    } 
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

function mostrarRiesgo(data) {
    const riskIndicator = document.getElementById('riskIndicator');
    if (!riskIndicator) return;

    if (data.riesgo === undefined || data.riesgo === null) {
        riskIndicator.textContent = "Riesgo: N/A";
        riskIndicator.style.backgroundColor = "#4a5568";
    } else {
        if (data.riesgo < 40) {
            riskIndicator.style.backgroundColor = "var(--success-color)";
            riskIndicator.textContent = `Riesgo: Bajo (${data.riesgo.toFixed(1)}%)`;
        } else if (data.riesgo < 70) {
            riskIndicator.style.backgroundColor = "var(--warning-color)";
            riskIndicator.textContent = `Riesgo: Medio (${data.riesgo.toFixed(1)}%)`;
        } else {
            riskIndicator.style.backgroundColor = "var(--danger-color)";
            riskIndicator.textContent = `Riesgo: Alto (${data.riesgo.toFixed(1)}%)`;
        }
    }
}

function calcularStepSize(tx, rx) {
    const maxTx = Math.max(...tx);
    const maxRx = Math.max(...rx);
    const maxValor = Math.max(maxTx, maxRx); 
    
    if (isNaN(maxValor) || maxValor === 0) return 100;
    if (maxValor <= 10) return 1;
    if (maxValor <= 50) return 5;
    if (maxValor <= 100) return 10;
    if (maxValor <= 500) return 50;
    if (maxValor <= 1000) return 100;
    return Math.ceil(maxValor / 10);
}

async function generarPDFReporte(hostname) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'pt', 'a4'); // 'p' para retrato, 'pt' para puntos, 'a4' para tamaño de página

    let yOffset = 40; // Margen superior inicial

    // Título principal del documento
    doc.setFontSize(22);
    doc.text("REPORTE DE MONITOREO DE DISPOSITIVO", doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
    yOffset += 30;

    // Nombre del dispositivo y riesgo
    doc.setFontSize(16);
    doc.text(`Dispositivo: ${hostname}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
    yOffset += 20;

    const riskIndicatorElement = document.getElementById('riskIndicator');
    if (riskIndicatorElement) {
        doc.setFontSize(12);
        doc.text(riskIndicatorElement.innerText, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
        yOffset += 30;
    }

    // 2. Capturar y añadir cada gráfico como imagen
    const chartContainers = document.querySelectorAll('.grafico-contenedor');
    for (const container of chartContainers) {
        const chartCanvas = container.querySelector('canvas');
        const chartTitle = container.querySelector('h3').innerText; // El título H3 del contenedor

        if (chartCanvas) {
            // Comprobar si hay suficiente espacio para el título y el gráfico
            const estimatedChartHeight = 350; // Estimación de la altura del gráfico + margen
            if (yOffset + 20 + estimatedChartHeight > doc.internal.pageSize.height - 40) {
                doc.addPage();
                yOffset = 40; // Reiniciar yOffset para la nueva página
            }

            // Añadir un título para el gráfico en el PDF
            doc.setFontSize(14);
            doc.text(chartTitle, 40, yOffset); // Margen izquierdo
            yOffset += 20; // Espacio después del título

            // Esperar a que html2canvas capture el canvas como imagen
            const canvasImage = await html2canvas(chartCanvas, {
                scale: 3, // Aumenta la escala para mejor calidad y legibilidad de ejes
                useCORS: true, 
                logging: false,
                width: chartCanvas.offsetWidth, // Capturar el ancho visible
                height: chartCanvas.offsetHeight // Capturar la altura visible
            });

            const imgData = canvasImage.toDataURL('image/png');
            let imgWidth = 550; // Ancho deseado para la imagen en el PDF
            let imgHeight = (canvasImage.height * imgWidth) / canvasImage.width;

            // Si la imagen es demasiado alta, escalar para que quepa en la página
            if (imgHeight > doc.internal.pageSize.height - yOffset - 40) {
                imgHeight = doc.internal.pageSize.height - yOffset - 40;
                imgWidth = (canvasImage.width * imgHeight) / canvasImage.height;
            }

            doc.addImage(imgData, 'PNG', (doc.internal.pageSize.width - imgWidth) / 2, yOffset, imgWidth, imgHeight);
            yOffset += imgHeight + 30; // Espacio después de la imagen
        }
    }

    // 3. Añadir información general de hardware
    // Aquí es donde harás la llamada al backend para obtener los datos.
    // Asumiendo el endpoint JSON: /api/dispositivo/<hostname>/hardware_data
    try {
        const response = await fetch(`/api/dispositivo/${hostname}/hardware_data`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const hardwareInfo = await response.json();

        // Añadir una nueva página para la información de hardware si es necesario
        if (yOffset + 100 > doc.internal.pageSize.height - 40) { // Estimar espacio para el título de sección
            doc.addPage();
            yOffset = 40;
        }

        doc.setFontSize(18);
        doc.text("INFORMACIÓN DETALLADA DEL HARDWARE", doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
        yOffset += 30;
        
        doc.setFontSize(10);
        doc.setTextColor(0, 0, 0); // Texto negro para mejor legibilidad en PDF

        // Función auxiliar para añadir texto formateado
        const addText = (label, value) => {
            const currentLine = `${label}: ${value}`;
            const textWidth = doc.getStringUnitWidth(currentLine) * doc.internal.pageSize.width / doc.internal.scaleFactor;
            
            // Si el texto excede el ancho de la página, añadirlo en una nueva línea o con salto de línea automático
            if (textWidth > doc.internal.pageSize.width - 80) { // 80pt = 40pt de margen a cada lado
                const splitText = doc.splitTextToSize(currentLine, doc.internal.pageSize.width - 80);
                doc.text(splitText, 40, yOffset);
                yOffset += (splitText.length * 12); // Aumentar yOffset por cada línea
            } else {
                doc.text(currentLine, 40, yOffset);
                yOffset += 12; // Espacio entre líneas
            }
            if (yOffset > doc.internal.pageSize.height - 40) {
                doc.addPage();
                yOffset = 40;
                doc.setFontSize(10); // Restaurar tamaño de fuente después de la página
                doc.setTextColor(0, 0, 0);
            }
        };

        // Recorrer el objeto hardwareInfo y añadirlo al PDF
        for (const section in hardwareInfo) {
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0); // Color para títulos de sección
            if (yOffset + 20 > doc.internal.pageSize.height - 40) { // Estimar espacio para el título de sección
                doc.addPage();
                yOffset = 40;
            }
            doc.text(section.toUpperCase(), 40, yOffset);
            yOffset += 15;
            doc.setFontSize(10);
            doc.setTextColor(0, 0, 0); // Restaurar color para detalles

            const details = hardwareInfo[section];
            if (typeof details === 'object' && !Array.isArray(details)) {
                for (const key in details) {
                    if (typeof details[key] === 'object' && !Array.isArray(details[key])) {
                        doc.text(`  ${key}:`, 50, yOffset); // Subsección indentada
                        yOffset += 12;
                        for (const subKey in details[key]) {
                            addText(`    ${subKey}`, details[key][subKey]); // Sub-subsección más indentada
                        }
                    } else if (Array.isArray(details[key])) {
                        doc.text(`  ${key}:`, 50, yOffset);
                        yOffset += 12;
                        details[key].forEach((item, index) => {
                            if (typeof item === 'object') {
                                for (const itemKey in item) {
                                    addText(`    ${itemKey} ${index + 1}`, item[itemKey]);
                                }
                            } else {
                                addText(`    ${item}`, '');
                            }
                        });
                    } else {
                        addText(`  ${key}`, details[key]);
                    }
                }
            } else if (Array.isArray(details)) {
                details.forEach((item, index) => {
                    if (typeof item === 'object') {
                        doc.text(`  Elemento ${index + 1}:`, 50, yOffset);
                        yOffset += 12;
                        for (const itemKey in item) {
                             if (typeof item[itemKey] === 'object' && !Array.isArray(item[itemKey])) {
                                doc.text(`    ${itemKey}:`, 60, yOffset);
                                yOffset += 12;
                                for (const subItemKey in item[itemKey]) {
                                    addText(`      ${subItemKey}`, item[itemKey][subItemKey]);
                                }
                            } else if (Array.isArray(item[itemKey])) {
                                doc.text(`    ${itemKey}:`, 60, yOffset);
                                yOffset += 12;
                                item[itemKey].forEach((arrItem, arrIndex) => {
                                    addText(`      ${arrItem}`, '');
                                });
                            } else {
                                addText(`    ${itemKey}`, item[itemKey]);
                            }
                        }
                    } else {
                        addText(`  - ${item}`, '');
                    }
                });
            } else {
                addText(`  ${section}`, details);
            }
            yOffset += 10; // Espacio extra después de cada sección
        }

    } catch (err) {
        console.error('Error al obtener datos de hardware:', err);
        // Puedes añadir un mensaje de error al PDF si lo deseas
        doc.setFontSize(12);
        doc.setTextColor(255, 0, 0); // Rojo
        doc.text("Error al cargar la información detallada del hardware.", 40, yOffset + 20);
        doc.text("Asegúrese de que el agente esté enviando estos datos.", 40, yOffset + 35);
        yOffset += 60;
    }
    
    // 4. Descargar el PDF
    doc.save(`Reporte_Dispositivo_${hostname}_${new Date().toISOString().slice(0, 10)}.pdf`);
}
</script>
{% endblock %}