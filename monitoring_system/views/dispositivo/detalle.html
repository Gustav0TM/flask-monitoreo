{% extends 'layout/templates.html' %}

{% block titulo %}Detalle del Dispositivo - {{ hostname }}{% endblock %}

{% block contenido %}
<header class="dashboard-header">
    Detalle del Dispositivo: {{ hostname }}
</header>

<main class="dashboard-main">
    <div class="titulo-con-riesgo">
        <h2 class="titulo-central">Monitoreo Gráfico en Tiempo Real</h2>
        <div id="riskIndicator" class="indicador-riesgo">Riesgo: N/A</div>
        <div class="header-actions">
            <a href="{{ url_for('dashboard.index') }}" class="boton-retroceso">
                Listado de Servidores
            </a>
            <button class="boton-descarga" id="downloadButton">
                <i class="fas fa-download"></i>
            </button>
        </div>
    </div>

    <div class="contenedor-graficos">
        
        {# Contenedor de CPU - Ahora el div completo es clickeable #}
        <div class="grafico-contenedor lineal clickable-chart" data-href="{{ url_for('dispositivo.detalle_hardware_cpu', hostname=hostname) }}">
            <h3>Uso de CPU</h3>
            <canvas id="cpuChart"></canvas>
        </div>

        {# Contenedor de Memoria - Ahora el div completo es clickeable #}
        <div class="grafico-contenedor circular clickable-chart" data-href="{{ url_for('dispositivo.detalle_hardware_memory', hostname=hostname) }}">
            <h3>Memoria (%)</h3>
            <canvas id="memoryChart"></canvas>
        </div>

        {# Contenedor de Disco - Ahora el div completo es clickeable #}
        <div class="grafico-contenedor circular clickable-chart" data-href="{{ url_for('dispositivo.detalle_hardware_disk', hostname=hostname) }}">
            <h3>Disco (%) - Particiones</h3>
            <canvas id="diskChart"></canvas>
        </div>

        {# Contenedor de Tx/Rx (GPU) - Ahora el div completo es clickeable #}
        <div class="grafico-contenedor lineal clickable-chart" data-href="{{ url_for('dispositivo.detalle_hardware_gpu', hostname=hostname) }}">
            <h3>Bytes Tx / Rx (MB)</h3>
            <canvas id="txRxChart"></canvas>
        </div>

    </div>
</main>
{% endblock %}

{% block extra_js %}
<script>
let cpuChartInstance = null;
let memoryChartInstance = null;
let diskChartInstance = null;
let txRxChartInstance = null;

document.addEventListener('DOMContentLoaded', () => {
    const hostname = "{{ hostname }}";

    function actualizarDetalle() {
        fetch(`/get_device_data/${hostname}`)
            .then(response => response.json())
            .then(data => {
                renderCharts(data);
                mostrarRiesgo(data);
            })
            .catch(err => console.error('Error al obtener datos del dispositivo:', err));
    }

    actualizarDetalle();
    setInterval(actualizarDetalle, 5000);

    // Lógica para hacer los contenedores de gráfico clickeables
    document.querySelectorAll('.clickable-chart').forEach(chartContainer => {
        chartContainer.addEventListener('click', () => {
            const href = chartContainer.getAttribute('data-href');
            if (href) {
                window.location.href = href;
            }
        });
    });

    // Lógica para el nuevo botón de descarga
    document.getElementById('downloadButton').addEventListener('click', () => {
        generarPDFReporte(hostname);
    });
});

function renderCharts(data) {
    const labels = data.timestamps; // Ya son milisegundos desde el backend

    if (cpuChartInstance) cpuChartInstance.destroy();
    if (memoryChartInstance) memoryChartInstance.destroy();
    if (diskChartInstance) diskChartInstance.destroy();
    if (txRxChartInstance) txRxChartInstance.destroy();

    // CPU
    const promedioCpu = data.cpu.length > 0 ? (data.cpu.reduce((sum, val) => sum + val, 0) / data.cpu.length).toFixed(1) : 'N/A';

    cpuChartInstance = new Chart(document.getElementById('cpuChart'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                label: `CPU (%) - Promedio: ${promedioCpu}%`,
                data: data.cpu,
                borderColor: '#00bcd4',
                backgroundColor: '#00bcd4',
                fill: false,
                tension: 0.3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, suggestedMax: 100, ticks: { stepSize: 10, color: 'white' }, grid: { color: '#4a5568' } },
                x: { 
                    type: 'time', 
                    time: {
                        unit: 'second', 
                        displayFormats: {
                            second: 'HH:mm:ss', 
                            minute: 'HH:mm'
                        },
                        tooltipFormat: 'HH:mm:ss'
                    },
                    grid: { color: '#4a5568' }, 
                    ticks: { 
                        color: 'white',
                        maxRotation: 45, 
                        minRotation: 45 
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                },
                datalabels: {
                    anchor: 'end',
                    align: 'top',
                    offset: 4,
                    color: 'black',
                    font: { size: 10, weight: 'normal' },
                    rotation: 0,
                    formatter: value => value.toFixed(1) + ' %'
                }
            }
        },
        plugins: [ChartDataLabels]
    });

    // Memoria
    const memoriaUso = data.memory.length > 0 ? data.memory[data.memory.length - 1] : 0;
    memoryChartInstance = new Chart(document.getElementById('memoryChart'), {
        type: 'doughnut',
        data: {
            labels: ['Usado (%)', 'Libre (%)'],
            datasets: [{ data: [memoriaUso, 100 - memoriaUso], backgroundColor: ['#ffee58', '#4a5568'] }]
        },
        options: {
            cutout: '70%',
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                },
                datalabels: {
                    formatter: (value, ctx) => `${value.toFixed(1)}%`,
                    color: function(ctx) {
                        return ctx.dataIndex === 0 ? 'black' : 'white';
                    },
                    font: { weight: 'normal', size: 12 }
                }
            }
        },
        plugins: [ChartDataLabels]
    });

// ===== Disco - Particiones (Usado y Libre con GB sobre las barras y porcentajes en la leyenda ordenados) =====

// 1. Obtener datos de particiones
const particiones = data.disks || {};
const particionesLabels = Object.keys(particiones);
const particionesUsado = Object.values(particiones);
const particionesLibre = particionesUsado.map(uso => 100 - uso);

const particionesTotalGb = data.disks_total_gb || {};
const particionesUsadoGb = data.disks_used_gb || {};

// 2. Solo los nombres al pie, en el mismo orden
const etiquetas = particionesLabels;

// 3. Construir leyenda dinámica en el mismo orden que las barras
let leyendaUsado = 'Usado (';
let leyendaLibre = 'Libre (';

etiquetas.forEach(label => {
    const porcentajeUsado = particiones[label] || 0;
    const porcentajeLibre = 100 - porcentajeUsado;
    leyendaUsado += `${label}: ${porcentajeUsado.toFixed(1)}% | `;
    leyendaLibre += `${label}: ${porcentajeLibre.toFixed(1)}% | `;
});

// Eliminar el último separador " | " y cerrar paréntesis
leyendaUsado = leyendaUsado.slice(0, -3) + ')';
leyendaLibre = leyendaLibre.slice(0, -3) + ')';

// 4. Render del gráfico
diskChartInstance = new Chart(document.getElementById('diskChart'), {
    type: 'bar',
    data: {
        labels: etiquetas,
        datasets: [
            {
                label: leyendaUsado,
                data: particionesUsado,
                backgroundColor: '#7b1fa2',
                datalabels: {
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    anchor: 'center',
                    align: 'center',
                    offset: 0,
                    formatter: (value, ctx) => {
                        const label = particionesLabels[ctx.dataIndex];
                        const usadoGb = particionesUsadoGb[label] || 0;
                        return `${usadoGb.toFixed(1)} GB`;
                    }
                }
            },
            {
                label: leyendaLibre,
                data: particionesLibre,
                backgroundColor: '#4a5568',
                datalabels: {
                    color: 'white',
                    font: { size: 10, weight: 'bold' },
                    anchor: 'center',
                    align: 'center',
                    offset: 0,
                    formatter: (value, ctx) => {
                        const label = particionesLabels[ctx.dataIndex];
                        const totalGb = particionesTotalGb[label] || 0;
                        const usadoGb = particionesUsadoGb[label] || 0;
                        const libreGb = (totalGb - usadoGb).toFixed(1);
                        return `${libreGb} GB`;
                    }
                }
            }
        ]
    },
    options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, suggestedMax: 100, ticks: { stepSize: 10, color: 'white' }, grid: { color: '#4a5568' }, stacked: true },
                x: { grid: { color: '#4a5568' }, stacked: true, ticks: { color: 'white' } }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });


    // Tx/Rx
    txRxChartInstance = new Chart(document.getElementById('txRxChart'), {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'Bytes Tx (MB)',
                    data: data.tx,
                    backgroundColor: '#69f0ae',
                    datalabels: {
                        anchor: 'end',
                        align: 'end',
                        offset: 4,
                        color: '#000',
                        font: { size: 10 },
                        rotation: -90,
                        formatter: value => value.toFixed(2) + ' MB'
                    }
                },
                {
                    label: 'Bytes Rx (MB)',
                    data: data.rx,
                    backgroundColor: '#ff5252',
                    datalabels: {
                        anchor: 'end',
                        align: 'start',
                        offset: -4,
                        color: '#000',
                        font: { size: 10 },
                        rotation: -90,
                        formatter: value => value.toFixed(2) + ' MB'
                    }
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, ticks: { stepSize: calcularStepSize(data.tx, data.rx), color: 'white' }, grid: { color: '#4a5568' } },
                x: { 
                    type: 'time', 
                    time: {
                        unit: 'second', 
                        displayFormats: {
                            second: 'HH:mm:ss', 
                            minute: 'HH:mm'
                        },
                        tooltipFormat: 'HH:mm:ss'
                    },
                    grid: { color: '#4a5568' }, 
                    ticks: { 
                        color: 'white',
                        maxRotation: 45, 
                        minRotation: 45 
                    } 
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        padding: 20,
                        color: 'white'
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

function mostrarRiesgo(data) {
    const riskIndicator = document.getElementById('riskIndicator');
    if (!riskIndicator) return;

    if (data.riesgo === undefined || data.riesgo === null) {
        riskIndicator.textContent = "Riesgo: N/A";
        riskIndicator.style.backgroundColor = "#4a5568";
    } else {
        if (data.riesgo < 40) {
            riskIndicator.style.backgroundColor = "var(--success-color)";
            riskIndicator.textContent = `Riesgo: Bajo (${data.riesgo.toFixed(1)}%)`;
        } else if (data.riesgo < 70) {
            riskIndicator.style.backgroundColor = "var(--warning-color)";
            riskIndicator.textContent = `Riesgo: Medio (${data.riesgo.toFixed(1)}%)`;
        } else {
            riskIndicator.style.backgroundColor = "var(--danger-color)";
            riskIndicator.textContent = `Riesgo: Alto (${data.riesgo.toFixed(1)}%)`;
        }
    }
}

function calcularStepSize(tx, rx) {
    const maxTx = Math.max(...tx);
    const maxRx = Math.max(...rx);
    const maxValor = Math.max(maxTx, maxRx); 
    
    if (isNaN(maxValor) || maxValor === 0) return 100;
    if (maxValor <= 10) return 1;
    if (maxValor <= 50) return 5;
    if (maxValor <= 100) return 10;
    if (maxValor <= 500) return 50;
    if (maxValor <= 1000) return 100;
    return Math.ceil(maxValor / 10);
}

async function generarPDFReporte(hostname) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'pt', 'a4'); // 'p' para retrato, 'pt' para puntos, 'a4' para tamaño de página

    // 1. Información General y Título
    const tituloPagina = document.querySelector('.dashboard-header').innerText;
    const tituloCentral = document.querySelector('.titulo-central').innerText; // Aunque no se usa directamente en el PDF, se puede mantener para referencia
    const riesgoTexto = document.getElementById('riskIndicator').innerText;

    let yOffset = 40; // Margen superior inicial

    doc.setFontSize(22);
    doc.text(tituloPagina, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
    yOffset += 30;

    doc.setFontSize(16);
    doc.text(`Dispositivo: ${hostname}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
    yOffset += 20;

    doc.setFontSize(12);
    doc.text(riesgoTexto, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
    yOffset += 30;


    // 2. Capturar y añadir cada gráfico como imagen

    const chartContainers = document.querySelectorAll('.grafico-contenedor');
    for (const container of chartContainers) {
        const chartCanvas = container.querySelector('canvas');
        const chartTitle = container.querySelector('h3').innerText;

        if (chartCanvas) {
            // Añadir un título para el gráfico en el PDF
            doc.setFontSize(14);
            doc.text(chartTitle, 40, yOffset); // Margen izquierdo
            yOffset += 20;

            // Esperar a que html2canvas capture el canvas como imagen
            const canvasImage = await html2canvas(chartCanvas, {
                scale: 2, // Aumenta la escala para mejor calidad
                useCORS: true, // Importante si tienes imágenes de fuentes externas
                logging: false // Desactiva logs de html2canvas
            });

            const imgData = canvasImage.toDataURL('image/png');
            const imgWidth = 500; // Ancho deseado para la imagen en el PDF
            const imgHeight = (canvasImage.height * imgWidth) / canvasImage.width;

            // Comprobar si hay suficiente espacio en la página actual
            if (yOffset + imgHeight > doc.internal.pageSize.height - 40) { // 40 es un margen inferior
                doc.addPage();
                yOffset = 40; // Reiniciar yOffset para la nueva página
                doc.setFontSize(14);
                doc.text(chartTitle, 40, yOffset);
                yOffset += 20;
            }

            doc.addImage(imgData, 'PNG', (doc.internal.pageSize.width - imgWidth) / 2, yOffset, imgWidth, imgHeight);
            yOffset += imgHeight + 30; // Espacio después de la imagen
        }
    }

    // 3. Descargar el PDF
    doc.save(`Reporte_Dispositivo_${hostname}_${new Date().toISOString().slice(0, 10)}.pdf`);
}
</script>
{% endblock %}